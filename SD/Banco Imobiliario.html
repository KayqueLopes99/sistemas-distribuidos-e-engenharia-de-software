<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Banco Imobili√°rio - Corrigido (posi√ß√µes)</title>
<style>
.cell.special-inicio { background:#b3d9ff; }
.cell.special-cadeia { background:#ffcc99; }
.cell.special-sorte  { background:#d9b3ff; }
.cell.special-imposto{ background:#ff9999; }
.cell.special-parada { background:#b3ffb3; }
.cell.owned { color:#fff; }

  :root{
    --grid-size: 7;
    --board-w: 900px;
  }
  body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#f3f3f3;display:flex;gap:12px;padding:12px;}
  #board{width:var(--board-w);height:var(--board-w);display:grid;grid-template-columns:repeat(7,1fr);grid-template-rows:repeat(7,1fr);gap:4px;background:#222;padding:8px;border-radius:8px;box-shadow:0 6px 30px rgba(0,0,0,.2);}
  .cell{background:#fff;border-radius:6px;border:2px solid #222;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:6px;box-sizing:border-box;position:relative;font-size:12px;text-align:center;}
  .corner{font-weight:700;background:#f5f5f5}
  .prop-name{font-weight:600;font-size:12px}
  .prop-price{font-size:11px;color:#444;margin-top:4px}
  .owner-tag{position:absolute;right:4px;bottom:4px;font-size:11px;color:#111;background:rgba(255,255,255,0.7);padding:2px 6px;border-radius:6px}
  .token{width:14px;height:14px;border-radius:50%;box-shadow:0 2px 6px rgba(0,0,0,.3);border:2px solid #fff;position:absolute;top:6px;left:6px}
  #sidebar{width:340px;background:#fff;padding:12px;border-radius:8px;box-shadow:0 6px 30px rgba(0,0,0,.12);display:flex;flex-direction:column;gap:8px}
  #players{display:flex;flex-direction:column;gap:6px}
  .player-line{display:flex;justify-content:space-between;align-items:center;padding:6px;border-radius:6px;background:rgba(0,0,0,0.03)}
  .controls{display:flex;flex-direction:column;gap:6px}
  button{padding:8px;border-radius:6px;border:1px solid #ccc;background:#fafafa;cursor:pointer}
  #log{height:320px;overflow:auto;background:#efefef;padding:8px;border-radius:6px;border:1px solid #ddd;font-size:13px}
</style>
</head>
<body>

<div id="board" aria-label="Tabuleiro"></div>

<aside id="sidebar">
  <h2>Banco Imobili√°rio (corrigido)</h2>
  <div id="players"></div>

  <div class="controls">
    <button id="rollBtn">üé≤ Rolar Dados</button>
    <button id="buyBtn" disabled>üí∞ Comprar Propriedade</button>
    <button id="endBtn">‚û°Ô∏è Encerrar Turno</button>
  </div>

  <h3>Log de Eventos</h3>
  <div id="log"></div>
</aside>

<script>
/* Config */
const GRID = 7;                // 7x7
const PATH_LENGTH = null;      // ser√° derivado do pathCoords
const START_MONEY = 1500;
const NUM_PLAYERS = 6;

/* estado */
const grid = [];               // grid[r][c] -> DOM cell
const pathCoords = [];         // array de {r,c} na ordem do percurso (clockwise)
let properties = [];           // propriedades (mesma ordem de pathCoords)
let players = [];              // jogadores
let current = 0;
let canBuy = false;

/* DOM */
const boardEl = document.getElementById('board');
const playersEl = document.getElementById('players');
const logEl = document.getElementById('log');
const rollBtn = document.getElementById('rollBtn');
const buyBtn = document.getElementById('buyBtn');
const endBtn = document.getElementById('endBtn');

/* cria grid 7x7 e pathCoords na ordem correta (sentido hor√°rio, iniciando em canto superior esquerdo) */
function createGridAndPath(){
  // criar elementos da grade e matriz grid[r][c]
  for(let r=0;r<GRID;r++){
    grid[r]=[];
    for(let c=0;c<GRID;c++){
      const cell = document.createElement('div');
      cell.className='cell';
      boardEl.appendChild(cell);
      grid[r][c]=cell;
    }
  }

  // construir pathCoords (clockwise) START: top-left (0,0) -> direita ao longo da linha superior -> desce coluna direita -> volta linha inferior -> sobe coluna esquerda
  // ordem: (0,0) .. (0,6), (1,6)..(6,6), (6,5)..(6,0), (5,0)..(1,0)
  for(let c=0;c<GRID;c++) pathCoords.push({r:0,c}); // placeholder to fill with unique coords below
  pathCoords.length = 0;

  // top row left->right
  for(let c=0;c<GRID;c++) pathCoords.push({r:0,c});
  // right column top->bottom excluding corner at (0,6)
  for(let r=1;r<GRID;r++) pathCoords.push({r,c:GRID-1});
  // bottom row right->left excluding corner (6,6)
  for(let c=GRID-2;c>=0;c--) pathCoords.push({r:GRID-1,c});
  // left column bottom->top excluding corners (6,0) and (0,0)
  for(let r=GRID-2;r>=1;r--) pathCoords.push({r,c:0});

  // now pathCoords length should be 24 for GRID=7
  // assign those coords properly (we used objects with keys in push but some are wrong: fix)
  // Actually above pushes used object shorthand incorrectly in some pushes; rebuild properly:

  pathCoords.length = 0;
  for(let c=0;c<GRID;c++) pathCoords.push({r:0,c:c});              // (0,0) .. (0,6)
  for(let r=1;r<GRID;r++) pathCoords.push({r:r,c:GRID-1});        // (1,6)..(6,6)
  for(let c=GRID-2;c>=0;c--) pathCoords.push({r:GRID-1,c:c});     // (6,5)..(6,0)
  for(let r=GRID-2;r>=1;r--) pathCoords.push({r:r,c:0});          // (5,0)..(1,0)
  // pathCoords ready
}

/* criar propriedades com o mesmo tamanho de pathCoords */
function createProperties(){
  const names = [
    'In√≠cio','Avenida 1','Sorte/Rev√©s','Avenida 2','Imposto',
    'Avenida 3','Cadeia/Visita','Avenida 4','Avenida 5','Sorte/Rev√©s',
    'Avenida 6','Imposto','Avenida 7','Parada Livre','Avenida 8',
    'Sorte/Rev√©s','Avenida 9','Avenida 10','Imposto','Avenida 11',
    'Sorte/Rev√©s','Avenida 12','Avenida 13','Multa'
  ];
  // garantir que names.length === pathCoords.length
  if(names.length !== pathCoords.length){
    // se n√£o bater, reduz/estende automaticamente (n√£o deveria acontecer)
    names.length = pathCoords.length;
  }

  properties = names.map((name,i) => {
    const special = /Sorte|Imposto|Cadeia|In√≠cio|Parada|Multa/i.test(name);
    return {
      id: i,
      name,
      price: special ? 0 : 100 + ((i*10) % 300),   // pre√ßos simples
      rent: special ? 0 : Math.max(10, Math.floor((100 + ((i*10)%300))/6)),
      owner: null
    };
  });

    // desenhar textos nas c√©lulas correspondentes
  for(let i=0;i<properties.length;i++){
    const {r,c} = pathCoords[i];
    const cell = grid[r][c];
    cell.dataset.pos = i;
    cell.innerHTML = `<div class="prop-name">${properties[i].name}</div>
                      ${properties[i].price ? `<div class="prop-price">R$ ${properties[i].price}</div>` : ''}`;

    // aplica classes especiais individualmente
    if(/In√≠cio/i.test(properties[i].name)) cell.classList.add('special-inicio');
    if(/Cadeia/i.test(properties[i].name)) cell.classList.add('special-cadeia');
    if(/Sorte/i.test(properties[i].name))  cell.classList.add('special-sorte');
    if(/Imposto|Multa/i.test(properties[i].name)) cell.classList.add('special-imposto');
    if(/Parada/i.test(properties[i].name)) cell.classList.add('special-parada');

    // marca tamb√©m como "corner" (bordas grandes)
    if(/In√≠cio|Cadeia|Parada|Multa|Imposto/i.test(properties[i].name)){
      cell.classList.add('corner');
    }
  }

}

/* inicializar jogadores */
function createPlayers(){
  const colors = ['#e74c3c','#3498db','#2ecc71','#f1c40f','#9b59b6','#e67e22'];
  players = [];
  for(let i=0;i<NUM_PLAYERS;i++){
    players.push({
      id: i,
      name: `Jogador ${i+1}`,
      money: START_MONEY,
      pos: 0,      // posi√ß√£o no pathCoords (0..pathCoords.length-1)
      bankrupt: false,
      color: colors[i]
    });
  }
}

/* UI: desenha tokens e lista de jogadores */
function renderPlayersUI(){
  // limpar tokens
  document.querySelectorAll('.token').forEach(t => t.remove());
  // desenhar tokens no respectivo cell (pode haver mais de um token por casa; distribuir offset)
  const placedCount = {}; // key pos -> count para deslocar tokens
  players.forEach(p => {
    if(p.bankrupt) return;
    const pos = p.pos;
    placedCount[pos] = (placedCount[pos]||0) + 1;
    const {r,c} = pathCoords[pos];
    const cell = grid[r][c];
    const token = document.createElement('div');
    token.className = 'token';
    token.style.background = p.color;
    // deslocamento simples: top-left + small offset por contagem
    const offset = placedCount[pos]-1;
    token.style.left = (6 + (offset*18)) + 'px';
    token.style.top  = (6) + 'px';
    token.title = p.name;
    cell.appendChild(token);
  });

  // players list
  playersEl.innerHTML = '';
  players.forEach((p,idx) => {
    const div = document.createElement('div');
    div.className = 'player-line';
    div.innerHTML = `<div style="display:flex;gap:8px;align-items:center"><div style="width:12px;height:12px;border-radius:50%;background:${p.color}"></div><strong>${p.name}</strong></div>
                     <div>${p.bankrupt?'<em>Falido</em>':'R$ '+p.money}${current===idx ? ' ‚Üê turno':''}</div>`;
    playersEl.appendChild(div);
  });
}

/* mostrar owner no cell */
function renderOwners(){
  // limpar estilos de ownership antes
  properties.forEach((prop,i)=>{
    const {r,c} = pathCoords[i];
    const cell = grid[r][c];
    cell.style.background = ""; 
    cell.classList.remove("owned");
  });

  properties.forEach((prop,i) => {
    const {r,c} = pathCoords[i];
    const cell = grid[r][c];
    if(prop.owner !== null){
      const color = players[prop.owner].color;
      cell.style.background = color;
      cell.classList.add("owned");
    } else {
      // reaplicar cores das especiais se n√£o tiver dono
      if(/In√≠cio/i.test(prop.name)) cell.classList.add('special-inicio');
      if(/Cadeia/i.test(prop.name)) cell.classList.add('special-cadeia');
      if(/Sorte/i.test(prop.name)) cell.classList.add('special-sorte');
      if(/Imposto|Multa/i.test(prop.name)) cell.classList.add('special-imposto');
      if(/Parada/i.test(prop.name)) cell.classList.add('special-parada');
    }
  });

  // remover owner tags antes
  document.querySelectorAll('.owner-tag').forEach(t => t.remove());
  properties.forEach((prop,i) => {
    if(prop.owner !== null){
      const {r,c} = pathCoords[i];
      const cell = grid[r][c];
      const tag = document.createElement('div');
      tag.className = 'owner-tag';
      tag.textContent = players[prop.owner].name;
      cell.appendChild(tag);
    }
  });
}


/* log */
function log(msg){
  const d = document.createElement('div');
  d.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
  logEl.prepend(d);
}

/* movimento e a√ß√µes */
let alreadyRolled = false; // controla se j√° rolou no turno atual

function rollDice(){
  const p = players[current];
  if(p.bankrupt) { nextTurn(); return; }

  if(alreadyRolled) { 
    log("Voc√™ j√° rolou o dado neste turno. Encerrre o turno ou espere um 6.");
    return; 
  }

  const d = Math.floor(Math.random()*6)+1; // s√≥ 1 dado
log(`${p.name} rolou ${d}`);

const oldPos = p.pos;
p.pos = (p.pos + d);

// se ultrapassou o final do tabuleiro ‚Üí deu a volta
if (p.pos >= pathCoords.length) {
    p.pos = p.pos % pathCoords.length;
    p.money += 200;
    log(`${p.name} passou pelo IN√çCIO e recebeu R$200!`);
}

handleLanding(p);

  renderPlayersUI();
  renderOwners();

  // se for 6 ‚Üí pode jogar de novo
  if(d === 6){
    log(`${p.name} tirou 6 e pode jogar de novo!`);
    alreadyRolled = false; // libera de novo
  } else {
    alreadyRolled = true;  // marcou que j√° rolou
    rollBtn.disabled = true; // trava bot√£o at√© passar turno
  }

  // se caiu em propriedade livre, habilita compra
  const prop = properties[p.pos];
  canBuy = (prop && prop.price>0 && prop.owner===null && !p.bankrupt);
  buyBtn.disabled = !canBuy;
}

function handleLanding(player){
  const prop = properties[player.pos];
  log(`${player.name} caiu em ${prop.name}`);
  if(prop.price === 0){
    // especiais
    if(/Imposto|Multa/i.test(prop.name)){
      const amt = 100;
      player.money -= amt;
      log(`${player.name} pagou imposto: R$${amt}`);
      checkBankruptcy(player);
    } else if(/Sorte/i.test(prop.name)){
      const val = Math.floor(Math.random()*301)-100; // -100..+200
      player.money += val;
      log(`${player.name} obteve carta: ${val>=0?'+':'-'}R$${Math.abs(val)}`);
      checkBankruptcy(player);
    } else if(/Cadei/i.test(prop.name)){
      log(`${player.name} est√° apenas visitando a cadeia.`);
    } else if(/In√≠cio/i.test(prop.name)){
      // passar pelo in√≠cio dar R$200? decidi dar s√≥ caso passe nele (aqui se cair diretamente, tamb√©m d√°)
      player.money += 200;
      log(`${player.name} recebeu R$200 no In√≠cio.`);
    }
  } else {
    if(prop.owner === null){
      log(`Propriedade dispon√≠vel: ${prop.name} por R$${prop.price}`);
      // bot√£o comprar habilitado no rollDice
    } else if(prop.owner !== player.id){
      const rent = prop.rent;
      player.money -= rent;
      players[prop.owner].money += rent;
      log(`${player.name} pagou R$${rent} de aluguel a ${players[prop.owner].name}`);
      checkBankruptcy(player);
    } else {
      log(`${player.name} caiu na sua pr√≥pria propriedade (${prop.name}).`);
    }
  }
}

/* comprar propriedade */
function buyProperty(){
  const p = players[current];
  const prop = properties[p.pos];
  if(!prop || prop.price===0 || prop.owner!==null){
    log('Nada para comprar aqui.');
    return;
  }
  if(p.money < prop.price){
    log('Dinheiro insuficiente para comprar.');
    return;
  }
  p.money -= prop.price;
  prop.owner = p.id;
  log(`${p.name} comprou ${prop.name} por R$${prop.price}`);
  canBuy = false;
  buyBtn.disabled = true;
  renderOwners();
  renderPlayersUI();
}

/* verifica√ß√£o de fal√™ncia */
function checkBankruptcy(player){
  if(player.money < 0 && !player.bankrupt){
    player.bankrupt = true;
    // devolver propriedades ao banco
    properties.forEach(pr => { if(pr.owner === player.id) pr.owner = null; });
    log(`${player.name} faliu e saiu do jogo.`);
    renderOwners();
    renderPlayersUI();
    // checar vencedor
    const alive = players.filter(p => !p.bankrupt);
    if(alive.length === 1){
      log(`üèÜ Vit√≥ria: ${alive[0].name}`);
      rollBtn.disabled = true;
      buyBtn.disabled = true;
      endBtn.disabled = true;
    }
  }
}

/* pr√≥ximo turno */
function nextTurn(){
  canBuy = false;
  buyBtn.disabled = true;
  rollBtn.disabled = false;  // libera bot√£o para pr√≥ximo jogador
  alreadyRolled = false;     // reseta flag

  // avan√ßa para pr√≥ximo jogador ativo
  let next = current;
  for(let i=1;i<=players.length;i++){
    const idx = (current + i) % players.length;
    if(!players[idx].bankrupt){ next = idx; break; }
  }
  current = next;
  renderPlayersUI();
  log(`Agora √© a vez de ${players[current].name}.`);
}

/* listeners */
rollBtn.addEventListener('click', ()=>{ rollDice(); });
buyBtn.addEventListener('click', ()=>{ buyProperty(); });
endBtn.addEventListener('click', ()=>{ nextTurn(); });

/* inicializa√ß√£o */
function init(){
  createGridAndPath();
  createProperties();
  createPlayers();
  renderPlayersUI();
  renderOwners();
  log('Jogo iniciado. √â a vez de ' + players[current].name);
}
init();

</script>
</body>
</html>
